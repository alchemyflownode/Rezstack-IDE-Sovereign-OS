// File: src/services/MemoryService.ts//  SOVEREIGN MEMORY SERVICE v1.1.0 - WITH PERSISTENCEexport interface Memory {  uuid: string;  text: string;  embedding: number[];  confidence: number;  usage_count: number;  last_accessed: string;  created: string;  metadata: Record<string, any>;  version: string;}export class MemoryService {  // Sovereign API Sync  async syncWithSovereign(): Promise<void> {    try {      const memories = this.getAllMemories();      const response = await fetch('http://localhost:9000/memory/sync', {        method: 'POST',        headers: { 'Content-Type': 'application/json' },        body: JSON.stringify({ memories })      });      if (response.ok) {        console.log(` Synced ${memories.length} memories with sovereign API`);      }    } catch (error) {      console.warn('Sovereign API not available for sync');    }  }  // Call sync after operations  async storeMemory(...args) {    const result = await this._storeMemory(...args);    await this.syncWithSovereign();    return result;  }  private memories: Map<string, Memory> = new Map();  private readonly DUPLICATE_THRESHOLD = 0.85;  private readonly PRUNE_CONFIDENCE = 0.3;  private readonly PRUNE_USAGE = 3;  private readonly VERSION = "1.1.0";  private storageKey = 'rezstack-memory-crystals';  constructor() {    this.loadMemories();    this.migrateV1toV1_1();    console.log(` Loaded ${this.memories.size} memories from disk`);  }  async storeMemory(text: string, confidence: number, metadata: Record<string, any> = {}): Promise<string> {    const embedding = this.generateEmbedding(text);    const duplicate = this.findDuplicate(embedding);        if (duplicate) {      return this.updateExistingMemory(duplicate.uuid, confidence);    }        return this.createNewMemory(text, embedding, confidence, metadata);  }  private findDuplicate(embedding: number[]): Memory | null {    let bestMatch: Memory | null = null;    let highestSimilarity = 0;        for (const memory of this.memories.values()) {      const similarity = this.cosineSimilarity(embedding, memory.embedding);      if (similarity > this.DUPLICATE_THRESHOLD && similarity > highestSimilarity) {        highestSimilarity = similarity;        bestMatch = memory;      }    }        if (bestMatch) {      console.log(` Duplicate found (${(highestSimilarity * 100).toFixed(1)}% similar)`);    }        return bestMatch;  }  private updateExistingMemory(uuid: string, confidence: number): string {    const memory = this.memories.get(uuid);    if (!memory) throw new Error(`Memory ${uuid} not found`);        memory.usage_count = (memory.usage_count || 0) + 1;    memory.last_accessed = new Date().toISOString();    memory.confidence = Math.max(memory.confidence, confidence);        this.saveMemories();    console.log(` Updated existing memory ${uuid} (usage: ${memory.usage_count})`);        return uuid;  }  private createNewMemory(text: string, embedding: number[], confidence: number, metadata: Record<string, any>): string {    const uuid = this.generateUUID();    const now = new Date().toISOString();        const memory: Memory = {      uuid,      text,      embedding,      confidence,      usage_count: 1,      last_accessed: now,      created: now,      metadata,      version: this.VERSION    };        this.memories.set(uuid, memory);    this.saveMemories();    console.log(` Created new memory crystal: ${uuid}`);        return uuid;  }  recallMemories(query: string, limit: number = 10): Memory[] {    const queryEmbedding = this.generateEmbedding(query);        const scored = Array.from(this.memories.values()).map(memory => {      const similarity = this.cosineSimilarity(queryEmbedding, memory.embedding);      const usageBoost = Math.min((memory.usage_count || 1) * 0.1, 2.0);      const score = similarity * (memory.confidence + usageBoost);      return { memory, score };    });        scored.sort((a, b) => b.score - a.score);        const results = scored.slice(0, limit).map(item => {      item.memory.usage_count = (item.memory.usage_count || 0) + 1;      item.memory.last_accessed = new Date().toISOString();      return item.memory;    });        this.saveMemories();    return results;  }  getMemory(uuid: string): Memory | null {    const memory = this.memories.get(uuid) || null;    if (memory) {      memory.usage_count = (memory.usage_count || 0) + 1;      memory.last_accessed = new Date().toISOString();      this.saveMemories();    }    return memory;  }  getAllMemories(): Memory[] {    return Array.from(this.memories.values());  }  private migrateV1toV1_1(): number {    let migrated = 0;        for (const memory of this.memories.values()) {      if (!memory.version || memory.version < "1.1.0") {        memory.usage_count = memory.usage_count || 0;        memory.last_accessed = memory.last_accessed || memory.created;        memory.version = this.VERSION;        migrated++;      }    }        if (migrated > 0) {      this.saveMemories();      console.log(` Migrated ${migrated} memories to v1.1.0`);    }        return migrated;  }  private cosineSimilarity(a: number[], b: number[]): number {    const dot = a.reduce((sum, val, i) => sum + val * b[i], 0);    const magA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));    const magB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));    if (magA === 0 || magB === 0) return 0;    return dot / (magA * magB);  }  private generateEmbedding(text: string): number[] {    // Simple deterministic embedding for testing    const embedding = new Array(128).fill(0);    for (let i = 0; i < text.length && i < 128; i++) {      embedding[i] = text.charCodeAt(i) / 255;    }    return embedding;  }  private generateUUID(): string {    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {      const r = Math.random() * 16 | 0;      const v = c === 'x' ? r : (r & 0x3 | 0x8);      return v.toString(16);    });  }  private saveMemories(): void {    try {      // Save to localStorage for persistence across page reloads      if (typeof localStorage !== 'undefined') {        const data = JSON.stringify(Array.from(this.memories.entries()));        localStorage.setItem(this.storageKey, data);        console.log(` Saved ${this.memories.size} memories to localStorage`);      }            // Also save to file system via API (optional)      fetch('/api/memory/save', {        method: 'POST',        headers: { 'Content-Type': 'application/json' },        body: JSON.stringify({ memories: Array.from(this.memories.entries()) })      }).catch(err => console.warn('Could not save to file:', err));          } catch (error) {      console.error('Failed to save memories:', error);    }  }  private loadMemories(): void {    try {      // Load from localStorage first      if (typeof localStorage !== 'undefined') {        const data = localStorage.getItem(this.storageKey);        if (data) {          this.memories = new Map(JSON.parse(data));          console.log(` Loaded ${this.memories.size} memories from localStorage`);          return;        }      }            // Fallback to empty map      this.memories = new Map();      console.log(' No existing memories found, starting fresh');          } catch (error) {      console.error('Failed to load memories:', error);      this.memories = new Map();    }  }}export const memoryService = new MemoryService();