// Sovereign Ecosystem Bridge - Connects IDE to all services// Auto-generated by integration scriptexport interface EcosystemStatus {  swarm: { status: 'connected' | 'disconnected'; url: string; name: string };  bridge: { status: 'connected' | 'disconnected'; url: string; name: string };  jarvis: { status: 'connected' | 'disconnected'; url: string; name: string };  sovereign: { status: 'connected' | 'disconnected'; url: string; name: string };  premium: { status: 'connected' | 'disconnected'; url: string; name: string };}export interface ServiceMetrics {  cpu?: number;  memory?: number;  tasks?: number;  latency?: number;  status?: string;}class EcosystemBridge {  private static instance: EcosystemBridge;  private status: EcosystemStatus = {    swarm: { status: 'disconnected', url: 'http://localhost:8000', name: 'Swarm API' },    bridge: { status: 'disconnected', url: 'http://localhost:8001', name: 'Constitutional Bridge' },    jarvis: { status: 'disconnected', url: 'http://localhost:8002', name: 'JARVIS API' },    sovereign: { status: 'disconnected', url: 'http://localhost:9000', name: 'Sovereign API' },    premium: { status: 'disconnected', url: 'http://localhost:8080', name: 'JARVIS IDE' }  };  private metrics: Map<string, ServiceMetrics> = new Map();  private listeners: ((status: EcosystemStatus) => void)[] = [];  private constructor() {    // Start health checks    setInterval(() => this.checkAllServices(), 30000);    this.checkAllServices();  }  static getInstance() {    if (!EcosystemBridge.instance) {      EcosystemBridge.instance = new EcosystemBridge();    }    return EcosystemBridge.instance;  }  async checkAllServices(): Promise<EcosystemStatus> {    const services = Object.entries(this.status);        await Promise.all(services.map(async ([key, service]) => {      try {        // Try health endpoint first        let response = await fetch(/health\, {           method: 'GET',          signal: AbortSignal.timeout(2000)        }).catch(() => null);                if (!response?.ok) {          // Try root endpoint as fallback          response = await fetch(service.url, {             method: 'GET',            signal: AbortSignal.timeout(2000)          }).catch(() => null);        }                const newStatus = response?.ok ? 'connected' : 'disconnected';        if (this.status[key as keyof EcosystemStatus].status !== newStatus) {          this.status[key as keyof EcosystemStatus].status = newStatus;          this.notifyListeners();        }      } catch {        if (this.status[key as keyof EcosystemStatus].status !== 'disconnected') {          this.status[key as keyof EcosystemStatus].status = 'disconnected';          this.notifyListeners();        }      }    }));    return this.status;  }  async getMetrics(service: keyof EcosystemStatus): Promise<ServiceMetrics | null> {    try {      const response = await fetch(/metrics\, {        signal: AbortSignal.timeout(2000)      });      if (response.ok) {        const data = await response.json();        this.metrics.set(service, data);        return data;      }    } catch {      // Silently fail    }    return this.metrics.get(service) || null;  }  async processWithSwarm(command: string, context?: any) {    const response = await fetch(/process\, {      method: 'POST',      headers: { 'Content-Type': 'application/json' },      body: JSON.stringify({ command, context, timestamp: Date.now() })    });    return response.json();  }  async getConstitutionalStatus() {    const response = await fetch(/status\);    return response.json();  }  async checkConstitutionalRule(rule: string, content: string) {    const response = await fetch(/check\, {      method: 'POST',      headers: { 'Content-Type': 'application/json' },      body: JSON.stringify({ rule, content })    });    return response.json();  }  async syncMemory(memories: any[]) {    const response = await fetch(/memory/sync\, {      method: 'POST',      headers: { 'Content-Type': 'application/json' },      body: JSON.stringify({ memories, source: 'ide', timestamp: Date.now() })    });    return response.json();  }  async queryJarvisModels() {    const response = await fetch(/models\);    return response.json();  }  subscribe(listener: (status: EcosystemStatus) => void) {    this.listeners.push(listener);    return () => {      this.listeners = this.listeners.filter(l => l !== listener);    };  }  private notifyListeners() {    this.listeners.forEach(l => l(this.status));  }  getStatus() {    return this.status;  }  isAnyConnected(): boolean {    return Object.values(this.status).some(s => s.status === 'connected');  }  getConnectedCount(): number {    return Object.values(this.status).filter(s => s.status === 'connected').length;  }}export const ecosystem = EcosystemBridge.getInstance();